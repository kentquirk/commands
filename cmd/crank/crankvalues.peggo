{
    package main
    
    import (
    "strconv"
    
    "github.com/oneiro-ndev/chaincode/pkg/chain"
    "github.com/oneiro-ndev/chaincode/pkg/vm"
    "github.com/oneiro-ndev/ndaumath/pkg/constants"
    )
}

Result <-
    ( v:Values EOF                          { return v.([]vm.Value), nil }
    / EOF                                   { return []vm.Value{}, nil }
    )

Values <-
    ( v:Value                               { return []vm.Value{v.(vm.Value)}, nil }
    / vs:Values ','? v:Value {
            va := append(vs.([]vm.Value), v.(vm.Value))
            return va, nil
        }
    )

Value <-
    ( Timestamp
    / Account
    / Number
    / Napu
    / Ndau
    / QuotedString
    / HexBytes
    / List
    / Struct
    )

Timestamp <- _ ts:([0-9-]+ 'T' [0-9:]+ 'Z') { return vm.ParseTimestamp(ts.(string)) }

Account <- _ "account"                      { return chain.ToValue(getRandomAccount()) }

Number <-
    ( BinaryNumber
    / OctalNumber
    / HexNumber
    / DecimalNumber
    )

BinaryNumber <- _ n:BinaryValue {
        x, err := parseInt(n.(string), 64)
        return vm.NewNumber(x), err
    }

BinaryValue <- "0b" [01_]+                  { return string(c.text), nil }

OctalNumber <- _ n:OctalValue {
        x, err := parseInt(n.(string), 64)
        return vm.NewNumber(x), err
    }

OctalValue <- '0' [0-7_]+                   { return string(c.text), nil }

HexNumber <- _ n:HexValue {
        x, err := parseInt(n.(string), 64)
        return vm.NewNumber(x), err
    }

HexValue <- "0x" [0-9a-fA-F_]+              { return string(c.text), nil }

DecimalNumber <- _ n:DecimalValue {
        x, err := parseInt(n.(string), 64)
        return vm.NewNumber(x), err
    }

DecimalValue <- '-'? [0-9_]+                { return string(c.text), nil }

Napu <- _ "np" n:DecimalValue {
        // napu is a base-10 positive integer preceded with np; it is delivered as an integer number of napu
        x, err := parseInt(n.(string), 64)
        return vm.NewNumber(x), err
    }

Ndau <- _ "nd" n:FloatValue {
        // ndau values are a base-10 positive decimal, which is multiplied by 10^8 and converted to integer
        x, err := strconv.ParseFloat(n.(string), 64)
        return vm.NewNumber(int64(x * constants.QuantaPerUnit)), err
    }

FloatValue <-
    ( [0-9_]* '.' [0-9_]+                   { return string(c.text), nil }
    / [0-9_]+ '.' [0-9_]+                   { return string(c.text), nil }
    / [0-9_]+ '.'?                          { return string(c.text), nil }
    )

QuotedString <-
    ( TripleSingle
    / TripleDouble
    / DoubleQuote
    / SingleQuote
    )

TripleSingle <- _ "'''" s:(.*) "'''"        { return vm.NewBytes(s.([]byte)), nil }
TripleDouble <- _ "\"\"\"" s:(.*) "\"\"\""  { return vm.NewBytes(s.([]byte)), nil }
DoubleQuote <- _ '"' s:([^"]*) '"'          { return vm.NewBytes(s.([]byte)), nil }
SingleQuote <- _ "'" s:([^']*) "'"          { return vm.NewBytes(s.([]byte)), nil }

HexBytes <- _ "B(" bs:(([0-9A-Fa-f][0-9A-Fa-f][_ ]*)+) ')' {
        // arrays of bytes are B(hex) with individual bytes as hex pairs with no 0x; embedded spaces and underscores are ignored
        ba := []byte{}
        pair := regexp.MustCompile("([0-9A-Fa-f][0-9A-Fa-f])")
        for _, it := range pair.FindAllString(bs.(string), -1) {
            b, _ := strconv.ParseInt(strings.TrimSpace(it), 16, 8)
            ba = append(ba, byte(b))
        }
        return vm.NewBytes(ba), nil
    }

Struct <- StructStart fl:Fields? StructEnd {
        str := vm.NewStruct()
        for _, i := range fl.([]vm.Value) {
            istr := i.(*vm.Struct)
            for _, ix := range istr.Indices() {
                v2, _ := istr.Get(ix)
                str = str.Set(ix, v2)
            }
        }
        return str, nil
    }

Fields <-
    ( f:Field                               { return []vm.Value{f.(vm.Value)}, nil }
    / fs:Fields ','? f:Field {
            fa := append(fs.([]vm.Value), f.(vm.Value))
            return fa, nil
        }
    )

Field <- _ id:FieldID _ ':' v:Value {
        // fields for structs are fieldid:Value; they are returned as a struct with one field that
        // is consolidated when they are enclosed in {} wrappers
        s := id.(string)
        if p, ok := predefined[s]; ok {
            s = p
        }
        fieldid, err := strconv.ParseInt(s, 10, 8)
        str := vm.NewStruct().Set(byte(fieldid), v.(vm.Value))
        return str, err
    }

FieldID <- ( [0-9]+ / [A-Z_]+ )             { return string(c.text), nil }

List <- ListStart vs:Values? ListEnd        { return vm.NewList(vs.([]vm.Value)...), nil }

StructStart <- _ '{'
StructEnd <- _ '}'
ListStart <- _ '['
ListEnd <- _ ']'

_ <- [ \t]*

Comment <- ';' [^\r\n]*

EOF <-
    ( !.
    / Comment !.
    )
